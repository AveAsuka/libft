#include "libft.h"

// Функция strlcpy копирует из строки src в буфер dst не более чем dstsize - 1 символов 
// и гарантированно устанавливает в конец строки нулевой символ. strlcat делает то же самое, 
// однако копирование ведётся не в начало dst, а таким образом, чтобы продолжить строку, 
// на которую указывает dst. 
// В случае, когда dst указывает на нуль-символ, поведение функций эквивалентно.

// куда (в конец) к основной строке, откуда (с начала) доп строку, сколько
size_t ft_strlcat(char * dst, const char * src, size_t dstsize)
{ // strlcpy возвращает размер строки по адресу src
   // я как понял перестраховку если массив NULL мы не делаем, так как restrict,
   // то есть указывает уже на конкретную область в памяти, то != 0

// strlcat возвращает суммарную длину строк по адресам src и dst. 
// Возвращаемое значение не зависит от того, удалось скопировать строку полностью или нет; 
// это позволяет легко определить что буфер назначения слишком мал для копируемой строки.
    size_t i;
    size_t j;
    size_t dest_length; // основная строка
    size_t src_length; // доп строка, которую присваиваем

    dest_length = ft_strlen(dst); // узнаем длину основной строки
    src_length = ft_strlen(src); // узнаем длину доп строки
	
    i = 0; // счетчик с начала доп строки
    j = ft_strlen(dst); // счетчик для конца основной строки

    // если прибавляем точно больше длины основной строки (с учетом нуля на конце)
    if (dstsize > 0 && (dstsize - 1) > dest_length) //сайз должен быть больше дэста с учетом нуля
    { // крутим если не конец доп строки И размер больше основная + текущая дополнительная
        while (src[i] && (dstsize - 1) > dest_length + i) // -1 так как надо учесть ноль в конце строки
        {
            dst[j] = src[i];
            i++;
            j++;
        }
        dst[j] = '\0';
    }

    if (src_length == 0) // если доп строка пуста, то возращаем только основную
        return (dest_length);

    if (dest_length == 0) // если основная строка пуста, то возращаем только доп
        return(src_length);

    // если основная строка больше равна "сколько добавляем", то ...
    if (dest_length >= dstsize)
        dest_length = dstsize; // ... урезаем до длины

    return (dest_length + src_length); // возращаем длину основной + дополнительной
}

// int main()
// {
//     char   str[100] = "образец строки";
//     size_t  sz;
 
//     char  buf[100];  // буфер размером меньше строки
//     buf[0] = '\0'; // избыточная инициализация для отладочной печати
    
//     printf("строка: \"%s\"\n\n", str);
//     printf("буфер перед копированием: \"%s\"\n", buf);
    
//     sz = strlcpy(buf, str, sizeof(buf));    
//     if (sz >= sizeof(buf))  // пример определения усечения строки      
//         printf("%zu\n", sz);
    
//     printf("буфер после копирования:  \"%s\"\n", buf);
    
//     return 0;
// }