#include "libft.h"

// Функция memmove копирует len байт из массива (области памяти), 
// на который указывает аргумент src, в массив (область памяти), 
// на который указывает аргумент dst. 
// При этом массивы (области памяти) могут пересекаться.

// Функция memcpy копирует n байт из массива (области памяти), 
// на который указывает аргумент src, в массив (область памяти), 
// на который указывает аргумент dst. 
// Если массивы перекрываются(???), результат копирования будет не определен.

void * ft_memmove(void *dst, const void *src, size_t len)
{
   if(!dst || !src)
      return (NULL);

   int i;

   // сравниваем адрес памяти, чтобы избежать наложений одинаковых элементов
   if (dst > (void *)(src)) // сурс слева, дест справа, то из конца в конец
   {
      i = (int)len - 1; // чтобы передать первый элемент
      while (i >= 0) 
      { // разыменовываем и присваиваем значения, это важно
        *(char *)(dst + i) =  *(char *)(src + i); 
         i--; // идем "справа налево"
      }
   }
   else  // дест слева, сурс справа, то из начала в начало
   {
      i = 0;
      while ((int)len > i)
      {
         *(char *)(dst + i) =  *(char *)(src + i);
         i++;
      }
   }

   return (dst);
}

// int main()
// {
//    char src[] = "******************************";
//    char dest[] = "abcdefghijklmnopqrstuvwxyz0123456789";
//    char kest[] = "abcdefghijklmnopqrstuvwxyz0123456789";

//    printf("Строка назначения перед копированием, оригинал: %s \n", dest);
//    memmove(dest,src,26);
//    printf("Строка назначения после копирования, оригинал: %s \n", dest);

//    printf("Строка назначения перед копированием, наша: %s \n", kest);
//    ft_memmove(dest,src,26);
//    printf("Строка назначения после копирования, наша: %s \n", dest);
   
//    return 0;
// }